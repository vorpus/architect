{"version":3,"sources":["webpack/bootstrap 2ba9613f3a7ce2b914e8","./lib/mazr.js","./lib/canvas.js","./lib/cell.js","./lib/array.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;AACH,EAAC;;;;;;;ACvCD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA,sBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,YAAY;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC1KA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACjFA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2ba9613f3a7ce2b914e8","const Canvas = require('./canvas');\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvas = document.getElementById('canvas');\n\n  canvas.width = Canvas.DIM;\n  canvas.height = Canvas.DIM;\n\n  const ctx = canvas.getContext('2d');\n\n  ctx.fillStyle = Canvas.BG_COLOR;\n  ctx.fillRect(0, 0, Canvas.DIM, Canvas.DIM);\n\n  const thisCanvas = new Canvas();\n\n  thisCanvas.draw(ctx);\n\n  function getMousePos(docCanvas, evt) {\n    var rect = docCanvas.getBoundingClientRect();\n    return {\n      x: evt.clientX - rect.left,\n      y: evt.clientY - rect.top\n    };\n  }\n\n  $(document).on(\"keydown\", (e) => {\n    thisCanvas.handleDirection(e.keyCode, e);\n    thisCanvas.draw(ctx);\n  });\n\n  $('.pathfind').on(\"click\", (e) => {\n    thisCanvas.reset();\n    thisCanvas.draw(ctx);\n  });\n\n  $('.solve').on(\"click\", (e) => {\n    thisCanvas.solve();\n    thisCanvas.draw(ctx);\n  });\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/mazr.js\n// module id = 0\n// module chunks = 0","const Cell = require('./cell.js');\nconst sampling = require('./array.js');\n\nclass Canvas {\n  constructor() {\n    this.x = Canvas.NUMROWS;\n    this.y = Canvas.NUMROWS;\n\n    this.cellHash = {};\n    this.cells = this.newCells();\n    this.traverse();\n\n    this.startPoint;\n    this.finishPoint;\n    this.path;\n  }\n\n  reset() {\n    this.cells = this.newCells();\n    this.traverse();\n  }\n\n  handleDirection(keyCode, e) {\n    switch(keyCode) {\n      case 87:\n      case 38:\n        e.preventDefault();\n        this.move([0,-1]);\n        break;\n      case 65:\n      case 37:\n        e.preventDefault();\n        this.move([-1,0]);\n        break;\n      case 83:\n      case 40:\n        e.preventDefault();\n        this.move([0,1]);\n        break;\n      case 68:\n      case 39:\n        e.preventDefault();\n        this.move([1,0]);\n        break;\n    }\n  }\n\n  move(direction) {\n    let newX = this.startPoint.x + direction[0];\n    let newY = this.startPoint.y + direction[1];\n\n    if (this.cells[newX][newY].status !== 'wall') {\n      this.startPoint.carve();\n      this.startPoint = this.cells[newX][newY];\n      this.startPoint.setStart();\n    }\n\n    if (this.startPoint.cellNum === this.finishPoint.cellNum) {\n      this.reset();\n    }\n  }\n\n  getRandomPoint() {\n    let randomPoint;\n    while (!randomPoint || randomPoint.status ==='wall') {\n      let randomRow = this.cells.sample();\n      randomPoint = randomRow.sample();\n    }\n    return randomPoint;\n  }\n\n  solve() {\n    this.path.forEach((pathPoint, idx) => {\n      if (idx === 0 || idx === this.path.length-1) {\n\n      } else {\n        pathPoint.setSolution();\n      }\n    });\n  }\n\n  traverse() {\n    let cellStack = [this.cellHash[1]];\n    let visited = [this.cellHash[1]];\n    let longestLength = 0;\n\n    while(cellStack.length) {\n      let myNeighbors = this.neighborCells(cellStack[cellStack.length-1], visited);\n      if (myNeighbors.length === 0) {\n        if (cellStack.length > longestLength) {\n          this.path = cellStack.slice(0);\n          longestLength = cellStack.length;\n          this.finishPoint = cellStack[cellStack.length-1];\n        }\n        cellStack.pop();\n        continue;\n      }\n      let nextCell = myNeighbors.sample();\n      visited.push(nextCell);\n      cellStack.push(nextCell);\n      this.carvePathBetween(cellStack[cellStack.length-2], nextCell)\n    }\n    this.startPoint = this.cellHash[1];\n    this.cellHash[1].setStart();\n    this.finishPoint.setFinish();\n  }\n\n  carvePathBetween(cellA, cellB) {\n    let pathX = (cellA.x + cellB.x)/2;\n    let pathY = (cellA.y + cellB.y)/2;\n\n    this.cells[pathX][pathY].carve();\n  }\n\n  printStack(cellStack) {\n    let elements = [];\n    cellStack.forEach((cell) => {\n      elements.push(cell.cellNum);\n    });\n    console.log(elements.join(', '))\n  }\n\n  newCells() {\n    let newGrid = [];\n    let cellNum = 1;\n    for (let i = 0; i < this.x; i++) {\n      newGrid[i] = [];\n      for (let j = 0; j < this.y; j++) {\n        if ( i % 2 === 1 && j % 2 === 1) {\n          newGrid[i][j] = new Cell(i, j, 'path', cellNum);\n          this.cellHash[cellNum] = newGrid[i][j];\n          cellNum++;\n        } else {\n          newGrid[i][j] = new Cell(i, j, 'wall', '');\n        }\n      }\n    }\n    return newGrid;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = Canvas.BG_COLOR;\n    ctx.fillRect(0, 0, Canvas.DIM, Canvas.DIM);\n\n    ctx.strokeStyle = '#222222'\n    for (let i = 0; i < this.x; i++) {\n      for (let j = 0; j < this.y; j++) {\n        this.cells[i][j].draw(ctx);\n      }\n    }\n  }\n\n  neighborCells(cell, visited) {\n    let neighbors = cell.neighbors();\n    let cellNeighbors = [];\n    neighbors.forEach((neighborCoord) => {\n      let targetCell = this.cells[neighborCoord[0]][neighborCoord[1]];\n      if (!visited.includes(targetCell)) {\n        cellNeighbors.push(targetCell)\n      }\n    });\n    return cellNeighbors;\n  }\n}\n\nCanvas.BG_COLOR = \"#ffffff\";\nCanvas.DIM = 710;\nCanvas.NUMROWS = 71;\nCanvas.CELLDIM = Canvas.DIM/Canvas.NUMROWS;\n\nmodule.exports = Canvas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/canvas.js\n// module id = 1\n// module chunks = 0","class Cell {\n  constructor(i, j, status, cellNum) {\n    this.x = i;\n    this.y = j;\n\n    this.status = status;\n    this.cellNum = cellNum;\n  }\n\n  clickMe() {\n    this.toggle();\n  }\n\n  toggle() {\n    if (this.status === 'path') {\n      this.status = 'wall';\n    } else {\n      this.status = 'path';\n    }\n  }\n\n  carve() {\n    this.status = 'path';\n  }\n\n  setStart() {\n    this.status = 'start';\n  }\n\n  setFinish() {\n    this.status = 'finish';\n  }\n\n  setSolution() {\n    this.status = 'solution';\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = '#000000'\n    let cellDim = Cell.GRIDSIZE;\n    ctx.font = \"16px sans-serif\";\n\n    if (this.status === 'wall') {\n      ctx.fillRect(cellDim*this.x, cellDim*this.y, cellDim, cellDim);\n    } else if (this.status === 'start') {\n      ctx.fillStyle = 'green'\n      ctx.fillRect(cellDim*this.x, cellDim*this.y, cellDim, cellDim);\n      ctx.fillStyle = '#000000'\n    } else if (this.status === 'finish') {\n      ctx.fillStyle = 'red'\n      ctx.fillRect(cellDim*this.x, cellDim*this.y, cellDim, cellDim);\n      ctx.fillStyle = '#000000'\n    } else if (this.status === 'solution'){\n      ctx.fillStyle = '#9cecc5'\n      ctx.fillRect(cellDim*this.x, cellDim*this.y, cellDim, cellDim);\n      ctx.fillStyle = '#000000'\n    } else {\n      // ctx.strokeRect(cellDim*this.x, cellDim*this.y, cellDim, cellDim);\n    }\n  }\n\n  neighbors() {\n    const neighborActions = [[2,0], [0,2], [-2,0], [0,-2]]\n    const gdSz = Cell.GRIDSIZE;\n    let neighborCells = [];\n    neighborActions.forEach((move) => {\n      let newX = move[0] + this.x;\n      let newY = move[1] + this.y;\n      if (newX < Cell.CELLS_X && newX >= 0 && newY < Cell.CELLS_Y && newY >= 0) {\n        neighborCells.push([newX, newY]);\n      }\n    });\n    return neighborCells;\n  }\n\n}\n\nCell.GRIDSIZE = 10;\nCell.CELLS_X = 71;\nCell.CELLS_Y = 71;\n\nmodule.exports = Cell;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/cell.js\n// module id = 2\n// module chunks = 0","Array.prototype.sample = function(){\n  return this[Math.floor(Math.random()*this.length)];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/array.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}